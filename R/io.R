#' Read 10x scATAC-seq fragment data
#'
#' @param fragments_tsv A fragments.tsv.gz file generated by cellranger-atac count in the outs/ directory
#' @param singlecell_csv A singlecell.csv file generated by cellranger-atac count in the outs/ directory for filtering. If NULL, will read all fragments.
#' @param min_reads A numeric value indicating the minimum number of reads required to retain a cell barcode. Default is 1000.
#' @param remove_chrM A logical value indicating whether or not to remove all fragments mapping to the mitochondrial genome. Default is TRUE
#' @param verbose A logical value indicating whether or not to display messages. Default is TRUE.
#'
#' @return a list of GenomicRanges objects, one per cell barcode
#' @export
read_10x_fragments <- function(fragments_tsv,
                               singlecell_csv,
                               min_reads = 1000,
                               remove_chrM = TRUE,
                               verbose = TRUE) {

  if(!file.exists(fragments_tsv)) {stop(paste("Can't find fragments.tsv.gz at", fragments_tsv))}

  if(!is.null(singlecell_csv)) {
    if(!file.exists(singlecell_csv)) {stop(paste("Can't find singlecell.csv at", singlecell_csv))}
    if(verbose) {cat("reading singlecell.csv\n")}
    singlecell <- data.table::fread(singlecell_csv)
    singlecell <- singlecell[-1,]
    if(verbose) {cat("filtering singlecell.csv\n")}
    singlecell <- singlecell[passed_filters >= min_reads,]
  }



  if(verbose) {cat("reading fragments.tsv.gz\n")}
  fragments <- vroom::vroom(fragments_tsv,
                            delim = "\t",
                            col_names = c("chr","start","end","barcode","n_reads"),
                            col_types = c(chr = "c", start = "i", end = "i", barcode = "c", n_reads = "-"))

  if(!is.null(singlecell_csv)) {
    if(verbose) {cat("filtering fragments.tsv.gz\n")}
    fragments <- fragments[fragments$barcode %in% singlecell$barcode,]
  }

  if(remove_chrM) {
    if(verbose) {cat("removing chrM from fragments\n")}
    fragments <- fragments[!fragments$chr %in% c("chrM","chrMT","M","MT"),]
  }

  if(verbose) {cat("splitting fragments by barcode\n")}
  split_fragments <- split(fragments, fragments$barcode)

  return(split_fragments)
}


#' Convert a list of fragment data.table to GenomicRanges
#'
#' @param fragments A list of data.tables generated by read_10x_fragments()
#' @param n_threads A numeric value indicating how many threads to use for parallelization. Only works on UNIX-like systems. Default is 1.
#'
#' @return a list of GRanges objects
#' @export
convert_fragments_gr <- function(fragments,
                                 n_threads = 1) {
  if(n_threads == 1) {
    lapply(fragments,
           function(x) {
             GenomicRanges::GRanges(seqnames = x[["chr"]],
                                    IRanges::IRanges(start = x[["start"]],
                                                     end = x[["end"]]))
           })
  } else {
    starting_order <- names(fragments)
    res <- parallel::mclapply(fragments,
                              function(x) {
                                GenomicRanges::GRanges(seqnames = x[["chr"]],
                                                       IRanges::IRanges(start = x[["start"]],
                                                                        end = x[["end"]]))
                              },
                              mc.cores = n_threads)
    res <- res[starting_order]
    return(res)
  }
}

#' Convert a list of fragment GenomicRanges to data.table
#'
#' @param fragments A list of GenomicRanges generated by convert_fragments_gr()
#' @param n_threads A numeric value indicating how many threads to use for parallelization. Only works on UNIX-like systems. Default is 1.
#'
#' @return a list of data.table objects
#' @export
convert_fragments_bed <- function(fragments,
                                 n_threads = 1) {
  if(n_threads == 1) {
    res <- lapply(fragments,
                  function(x) {
                    data.table(chr = as.character(seqnames(x)),
                               start = start(x),
                               end = end(x))
                  })
  } else {
    starting_order <- names(fragments)
    res <- parallel::mclapply(fragments,
                              function(x) {
                                data.table(chr = as.character(seqnames(x)),
                                           start = start(x),
                                           end = end(x))
                              },
                              mc.cores = n_threads)
    res <- res[starting_order]
    return(res)
  }
}


#' Convert a list of fragment data.tables to a sparse matrix of genomic window counts
#'
#' @param fragments A list of data.tables generated by read_10x_fragments()
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#' @param genome A character object specifying which genome to use. Should be one of "hg38","hg19","mm10", or "mm9". Default is "hg38".
#' @param n_threads A numeric value indicating how many threads to use for parallelization. Only works on UNIX-like systems. Default is 1.
#'
#' @return a list of GRanges objects
#' @export
convert_fragments_windows <- function(fragments,
                                      window_size = 5e3,
                                      genome = "hg38",
                                      n_threads = 1) {

  chrom_sizes <- read_chrom_sizes(genome = genome,
                                  window_size = window_size)

  if(n_threads == 1) {
    window_counts <- lapply(fragments,
                            fragments_to_window_counts,
                            chrom_sizes,
                            window_size = window_size)
  } else {
    starting_order <- names(fragments)
    window_counts <- parallel::mclapply(fragments,
                                        fragments_to_window_counts,
                                        chrom_sizes,
                                        window_size = window_size,
                                        mc.cores = n_threads)
  }

  window_n_fragments <- unlist(lapply(window_counts, length))
  n_windows <- sum(chrom_sizes$n_windows)

  window_positions <- window_index_to_bed(1:n_windows,
                                          chrom_sizes = chrom_sizes,
                                          window_size = window_size)

  window_positions <- paste(window_positions$chr,
                            window_positions$start,
                            window_positions$end,
                            sep = "_")

  sparseMatrix(x = as.numeric(unlist(window_counts)),
               i = as.numeric(unlist(lapply(window_counts, names))),
               p = c(0, cumsum(window_n_fragments)),
               dim = c(n_windows,
                       length(fragments)),
               dimnames = list(window_positions,
                               names(fragments)))

}

#' Read chromosome sizes for a genome and precompute offsets for windowing
#'
#' All chromosome sizes are sourced from the UCSC Genome Browser
#'
#' @param genome A character object specifying which genome to use. Should be one of "hg38","hg19","mm10", or "mm9". Default is "hg38".
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#'
#' @return a data.frame with columns chr, size, n_windows, and offsets.
#' @export
read_chrom_sizes <- function(genome = "hg38",
                             window_size = 5e3) {

  chrom_sizes_file <- system.file(paste0("reference/",
                                         genome,
                                         ".chrom.sizes"),
                                  package = "scATAC_Seq_Pipeline")

  chrom_sizes <- read.table(chrom_sizes_file,
                            col.names = c("chr","size"),
                            header = FALSE,
                            sep = "\t",
                            stringsAsFactors = FALSE)

  chrom_sizes$n_windows <- ceiling(chrom_sizes$size / window_size)
  chrom_sizes$offset <- c(0, cumsum(chrom_sizes$n_windows)[-nrow(chrom_sizes)])

  chrom_sizes
}

#' Convert a data.table of fragment positions to a named vector of window counts
#'
#' @param fragment_dt A data.table of fragment positions, e.g. as generated by read_10x_fragments()
#' @param chrom_sizes A data.frame of chromosome sizes, e.g. as generated by read_chrom_sizes()
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#'
#' @return A named numeric vector of reads per window. Names will be numeric window indexes.
#' @export
fragments_to_window_counts <- function(fragment_dt,
                                       chrom_sizes,
                                       window_size = 5e3) {

  centers <- (fragment_dt$end + fragment_dt$start)/2
  chr_windows <- ceiling(centers / window_size)

  adj_windows <- chr_windows + chrom_sizes$offset[match(fragment_dt[[1]], chrom_sizes$chr)]

  table(adj_windows)
}

#' Convert a vector of window indexes to a BED-like table of chromosome positions for each window.
#'
#' @param window_indexes a numeric vector of window indexes
#' @param chrom_sizes A data.frame of chromosome sizes, e.g. as generated by read_chrom_sizes()
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#'
#' @return a data.table of chromosome positions, with columns chr, start, and end
#' @export
window_index_to_bed <- function(window_indexes,
                                chrom_sizes,
                                window_size = 5e3) {

  chr_bin <- as.numeric(cut(x = window_indexes,
                            breaks = chrom_sizes$offset,
                            right = FALSE))
  chr <- chrom_sizes$chr[chr_bin]

  chr_windows <- window_indexes - chrom_sizes$offset[chr_bin]

  bed <- data.table::data.table(chr = chr,
                         start = (chr_windows - 1) * window_size + 1,
                         end = chr_windows * window_size)

  chr_ends <- which(window_indexes %in% (chrom_sizes$offset))

  if(length(chr_ends) > 0) {
    end_chr <- chr[chr_ends]
    offset_idx <- match(window_indexes[chr_ends], chrom_sizes$offset) - 1

    bed$end[chr_ends] <- chrom_sizes$size[offset_idx]
  }

  bed
}

#' Convert a vector of window indexes to GenomicRanges positions for each window.
#'
#' @param window_indexes a numeric vector of window indexes
#' @param chrom_sizes A data.frame of chromosome sizes, e.g. as generated by read_chrom_sizes()
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#'
#' @return a non-stranded GenomicRanges object
#' @export
window_index_to_gr <- function(window_indexes,
                               chrom_sizes,
                               window_size = 5e3) {

  chr_bin <- as.numeric(cut(window_indexes, chrom_sizes$offset))
  chr <- chrom_sizes$chr[chr_bin]

  chr_windows <- window_indexes - chrom_sizes$offset[chr_bin]

  GenomicRanges::GRanges(chr = chr,
                         IRanges::IRanges(start = chr_windows * window_size,
                                          end = (chr_windows + 1) * window_size))

}

merge_gr_list <- function(gr_list) {
  gr <- GenomicRanges::GRanges(seqnames = unlist(lapply(gr_list, GenomicRanges::seqnames)),
                               IRanges::IRanges(start = unlist(lapply(gr_list, GenomicRanges::start)),
                                                end = unlist(lapply(gr_list, GenomicRanges::end))),
                               strand = unlist(lapply(gr_list, GenomicRanges::strand)))

  GenomicRanges::sort(gr)
}

#' Perform LogTF-IDF on a sparse, binary matrix
#'
#' TF-IDF is Term Frequency-Inverse Document Frequency.
#'
#' This function includes log scaling, as suggested by Andrew Hill.
#'
#' @param atac_matrix A binary, dgCMatrix of overlaps between cells (columns) and peaks (rows).
#' @param site_frequency_threshold A minimum threshold for the fraction of cells for which each peak must be positive to be retained. Ignored if idf is supplied.
#' @param weight_threshold (optional) Threshold (>= site_frequency_threshold) to avoid over-weighting rare events. Default is equal to site_frequency_threshold.
#' @param idf (optional) A precomputed, named numeric vector of IDF weights to apply to the data. Default is NULL, which uses the atac_matrix to compute IDF.
#'
#' @return a sparse matrix of filtered and scaled count values
#' @export
#'
atac_tf_idf <- function(atac_matrix,
                        site_frequency_threshold = 0.03,
                        weight_threshold = site_frequency_threshold,
                        idf = NULL) {

  cells_per_feature <- Matrix::rowSums(atac_matrix)

  if(is.null(idf)) {
    site_frequency <- cells_per_feature / ncol(atac_matrix)

    filtered_matrix <- atac_matrix[site_frequency >= site_frequency_threshold,]
    filtered_site_frequency <- site_frequency[site_frequency >= site_frequency_threshold]

    if(weight_threshold > site_frequency_threshold) {
      filtered_weight_ratio <- weight_threshold / filtered_site_frequency
      adjust_rows <- filtered_weight_ratio > 1

      filtered_matrix[adjust_rows,] <- filtered_matrix[adjust_rows,] / filtered_weight_ratio[adjust_rows]
    }

  } else {
    filtered_matrix <- atac_matrix[names(idf),]
  }

  ## Normalize the data with TF-IDFx
  col_sums <- Matrix::colSums(filtered_matrix)
  n_rep <- diff(filtered_matrix@p)

  filtered_matrix@x <- filtered_matrix@x / rep(col_sums, n_rep)
  filtered_matrix@x <- log1p(filtered_matrix@x * 1e5)

  if(is.null(idf)) {
    idf <- log(1 + ncol(filtered_matrix) / Matrix::rowSums(filtered_matrix))
  }

  tf_idf_counts <- filtered_matrix * idf

  tf_idf_counts@x[is.na(tf_idf_counts@x)] <- 0
  names(tf_idf_counts@x) <- NULL

  list(tf_idf = tf_idf_counts,
       idf = idf)
}

#' Perform SVD on TF-IDF scaled values
#'
#' @param tf_idf_mat A dgCMatrix of LogTF-IDF scaled values, e.g. as generated by atac_tf_idf()$tf_idf_mat
#' @param seed A numeric value to use as a random seed. Default is 3030.
#'
#' @return A list with two objects: pcs, a VD matrix from singular value decomposition; and feature_loadings, a UD matrix from SVD.
#' @export
atac_svd <- function(tf_idf_mat,
                     seed = 3030) {
  set.seed(seed)
  SVD <- irlba::irlba(tf_idf_mat, 50, 50, maxit=1000)
  d_diag <- matrix(0, nrow=length(SVD$d), ncol=length(SVD$d))
  diag(d_diag) <- SVD$d

  SVD_vd <- Matrix::t(d_diag %*% Matrix::t(SVD$v))
  rownames(SVD_vd) <- colnames(tf_idf_mat)
  colnames(SVD_vd) <- paste0('pc_', 1:ncol(SVD_vd))

  rownames(SVD$u) <- rownames(tf_idf_mat)
  colnames(SVD$u) <- paste0('pc_', 1:ncol(SVD_vd))

  list(pcs = SVD_vd,
       feature_loadings = SVD$u)
}

#' Perform Latent Semantic Indexing of a binary matrix
#'
#' This is a wrapper around two functions: atac_tf_idf() and atac_svd()
#'
#' @param atac_matrix A binary, dgCMatrix of overlaps between cells (columns) and peaks (rows).
#' @param site_frequency_threshold A minimum threshold for the fraction of cells for which each peak must be positive to be retained.
#' @param seed A numeric value to use as a random seed. Default is 3030.
#'
#' @return A list with two objects: pcs, a VD matrix from singular value decomposition; and feature_loadings, a UD matrix from SVD.
#' @export
atac_lsi <- function(atac_matrix,
                     site_frequency_threshold = 0.03,
                     seed = 3030) {

  tf_idf_res <- atac_tf_idf(atac_matrix,
                            site_frequency_threshold)

  atac_svd(tf_idf_res$tf_idf,
           seed = seed)
}

#' Project a query TF-IDF dataset onto a target SVD space.
#'
#' Both query_tf_idf and target_tf_idf must have common features.
#'
#' @param query_tf_idf A matrix of TF-IDF results, e.g. as generated by atac_tf_idf()$tf_idf
#' @param target_svd SVD results for the target dataset, e.g. as generated by atac_svd() or atac_lsi()
#'
#' @export
#'
atac_lsi_projection <- function(query_tf_idf,
                                target_svd) {

  common_features <- intersect(rownames(query_tf_idf),
                               rownames(target_svd$feature_loadings))

  query_tf_idf <- query_tf_idf[common_features,]
  target_loadings <- target_svd$feature_loadings[common_features,]

  query_projection <- Matrix::t(Matrix::crossprod(target_loadings,
                                                  query_tf_idf))

  colnames(query_projection) <- colnames(target_svd$pcs)

  as.matrix(query_projection)

}

#' Use LSI results to project onto a common low-dimensionality space using CCA
#'
#' @param atac_lsi_1 LSI representation of cells, i.e. as generated by atac_lsi()$pcs
#' @param atac_lsi_2 LSI representation of cells, i.e. as generated by atac_lsi()$pcs
#' @param seed A numeric value to use as a random seed. Default is 3030.
#'
#' @return a list with two objects: ccv, a matrix of CC dimensions, and d from SVD
#' @export
atac_lsi_cca <- function(atac_lsi_1,
                         atac_lsi_2,
                         seed = 3030) {

  atac_pcs_1 <- scale(t(atac_lsi_1), center = TRUE)
  atac_pcs_2 <- scale(t(atac_lsi_2), center = TRUE)

  crossprod_mat <- crossprod(atac_pcs_1,
                             atac_pcs_2)

  if(!is.null(seed)) {
    set.seed(seed)
  }

  SVD <- irlba::irlba(crossprod_mat, 50, 50, maxit = 1000)

  SVD_uv <- rbind(SVD$u, SVD$v)
  colnames(SVD_uv) <- paste0("cc_", 1:50)
  rownames(SVD_uv) <- c(colnames(atac_pcs_1),
                        colnames(atac_pcs_2))

  SVD_uv <- apply(SVD_uv, 2, function(x) { x * sign(x[1]) })

  list(ccv = SVD_uv,
       d = SVD$d)
}

#' Transfer labels from a reference based on CCA results
#'
#' @param ccv CCV matrix, as generated by atac_lsi_cca()$ccv
#' @param reference_names row.names of ccv for cells from the reference set
#' @param reference_labels a vector of labels to transfer from the reference. Should have the same order and length as reference_names.
#' @param query_names row.names of ccv for cells from the query set
#' @param k Number of nearest-neighbors to use for label transfer. Default is 20
#'
#' @return A data.frame with 3 columns: barcodes (query_names) of query cells; reference_label, and reference_score.
#' @export
atac_cca_label_transfer <- function(ccv,
                                    reference_names,
                                    reference_labels,
                                    query_names,
                                    k = 20) {

  reference_ccv <- ccv[reference_names,]
  query_ccv <- ccv[query_names,]

  knn <- RANN::nn2(data = reference_ccv,
                   query = query_ccv,
                   k = k)

  knn_types <- lapply(1:nrow(knn$nn.idx), function(x) {
    labels <- reference_labels[knn$nn.idx[x,]]
    label_freqs <- table(labels)
    label_freqs <- label_freqs[order(label_freqs, decreasing = TRUE)]
    data.frame(reference_label = names(label_freqs)[1],
               reference_label_score = label_freqs[1] / k)
  })
  knn_types <- do.call("rbind", knn_types)

  results <- cbind(data.frame(barcodes = query_names),
                   knn_types)

  return(results)
}
